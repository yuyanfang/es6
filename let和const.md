### let和const
#### let
1. let命令所在的**代码块**内有效。
2. let命令**不存在变量提升**。如果没有声明，不能使用，所以就会产生**暂时性死区**，而var没有声明，则可以可以使用为undefined。
3. let不允许在相同作用域内，重复声明同一个变量。  
> 声明提前，函数里面声明的所有变量（但不涉及赋值），都被提前到函数体的顶部。
#### 块级作用域
1. ES6 允许块级作用域的任意嵌套。
2. 外层作用域无法,取内层作用域的变量,内层作用域可以定义外层作用域的同名变量。
3.块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
```js
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```
4. ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之后不可引用。
（但是运行环境差异太大，应该避免使用）
#### do表达式
1. 因为块级表达式没有返回值，则现在又一个提案，使用do表达式，来返回整个块级作用域。  
```js
let x = do {
  let t = f();
  t * t + 1;
};
```
#### const命令
1. const声明一个只读的常量。一旦声明，常量的值就不能改变。
2. const一旦声明变量，就必须立即初始化，只声明不赋值，就会报错。
3. const的作用域与let命令相同：只在声明所在的块级作用域内有效。
4. const而是变量指向的那个**内存地址**不得改动。对于简单类型的数据（数值、字符串、布尔值），
值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，
const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。
#### ES6声明的六种方法
ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。
所以，ES6 一共有6种声明变量的方法。
#### 顶层对象
为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；
另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
```js
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
```
* 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
* 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。
* Node 里面，顶层对象是global，但其他环境都不支持。






